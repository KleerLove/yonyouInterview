<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        class Loli {
            //共有属性
            name
            //构造函数
            constructor(name) {
                this.name = name
            }
            //公有方法
            doi() {
                console.log('i wanna doi with you');
            }
        }
        const chino = new Loli('chino')
        console.log(chino);
        chino.doi()

        //1.class实现继承
        class Younv extends Loli {//extends继承
            age
            constructor(name, age) {
                super(name)//调用父类的构造函数
                this.age = age
            }
        }
        const klee = new Younv('klee', 8)
        console.log(klee);
        // console.log(klee.__proto__.constructor);
        klee.doi()//继承了父类的方法

        //2.寄生组合式继承
        function dad(name) {
            this.name = name
        }
        dad.prototype.say = function () {
            console.log(`my name is ${this.name}`);
        }

        //通过构造函数继承属性
        function son(name) {
            dad.call(this, name)
        }
        // son.prototype = Object.create(dad.prototype, {
        //     constructor: {
        //         value: son
        //     }
        // 通过传递constructor属性，可以确保son.prototype.constructor指向正确的构造函数（即son）。
        // 这样做主要是为了防止由于重写son.prototype而导致constructor属性丢失的问题
        // })
        son.prototype = Object.create(dad.prototype)//通过原型链继承方法

        const erzi = new son('erzi')
        console.log(erzi);
        erzi.say()

        //原型链继承
        //构造函数继承
        //组合继承
    </script>
</body>

</html>